---
title: 'Arquitectura limpia en Nest JS'
date: 2025-07-27
description: 'Una plantilla de una aplicación NestJS que implementa Clean Architecture, un ejemplo práctico del poder de esta arquitectura.'
author: Alan LB
image: 'images/clean-architecture-nestjs.webp'
tags: [NestJS, Clean Architecture, Template Projects, Backend, NestJS, Software Architecture]
isDraft: false
---

# Introducción

En este artículo exploraremos **cómo implementar Clean Architecture en un proyecto NestJS**, entendiendo cuándo conviene aplicarla y utilizando una plantilla práctica que puedes adaptar a tus proyectos.

El objetivo es **ser directo y práctico**, evitando la teoría innecesaria y centrándonos en **la aplicación real** de estos principios.

---

# Qué es Clean Architecture

**Clean Architecture** es un enfoque de diseño de software que busca **separar las responsabilidades** y mantener la **independencia** respecto a frameworks, bases de datos o interfaces de usuario.

En otras palabras, si mañana cambias la base de datos, una dependencia o incluso el framework, **no deberías tener que reescribir medio proyecto**.  
Esta arquitectura promueve flexibilidad, mantenibilidad y escalabilidad.

---

# Ventajas y desventajas de Clean Architecture

Como todo enfoque, Clean Architecture tiene beneficios y costos.

- **Ventajas:**
  - Código modular y mantenible.
  - Facilita el testing y la reutilización.
  - Permite cambiar tecnologías sin afectar la lógica del negocio.

- **Desventajas:**
  - Mayor complejidad inicial.
  - Curva de aprendizaje más alta.
  - Puede ser excesivo para proyectos pequeños o de corta vida.

Clean Architecture **tiene sentido cuando el proyecto busca evolucionar y escalar** en el tiempo. Si es un prototipo o una aplicación simple, quizá no sea la mejor opción.

---

# Capas de Clean Architecture

Aunque los nombres pueden variar según el proyecto, el principio clave es siempre el mismo:  
**separar responsabilidades y mantener el dominio independiente de los detalles técnicos**.

Una estructura típica en **NestJS** puede verse así:

## Domain (o Core)

Contiene el **corazón del negocio**, completamente independiente de frameworks o librerías externas.

Incluye:
- **Entidades:** representan los conceptos principales del dominio.
- **Reglas de negocio:** validaciones y lógica pura.
  
**Objetivo:** esta capa debe poder funcionar sin importar si se usa NestJS, Express u otro framework.

---

## Application (o Use Cases)

Define **qué hace el sistema** y **cómo interactúan sus partes internas**.

Incluye:
- Casos de uso que orquestan la lógica de negocio.
- Interfaces o puertos que la infraestructura debe implementar (por ejemplo, repositorios).

**Objetivo:** contener la lógica de aplicación sin depender de implementaciones concretas.

---

## Infrastructure

Contiene todas las **implementaciones técnicas concretas**.

Incluye:
- Repositorios que implementan los puertos del dominio.
- Integraciones con APIs externas, ORM, servicios de mensajería, etc.
- Configuración de NestJS.

**Objetivo:** si decides cambiar de ORM (por ejemplo, de TypeORM a Prisma), solo deberías modificar esta capa.

---

## Presentation (o Interface Adapters)

Es la **puerta de entrada** al sistema.

Incluye:
- Controladores (REST, GraphQL, gRPC, etc.).
- DTOs y validaciones de entrada/salida.

**Objetivo:** exponer la lógica de aplicación sin que las reglas de negocio conozcan los detalles técnicos.

---

# Ejemplo práctico: Clean Architecture con NestJS

Para comprender mejor, construiremos una pequeña aplicación en **NestJS** aplicando estos principios.

## Tecnologías utilizadas

- **TypeScript:** tipado fuerte en todas las capas.  
- **NestJS:** framework principal para la capa de presentación.  
- **Prisma ORM:** manejo de base de datos de forma tipada y moderna.  
- **PostgreSQL (Docker):** base de datos relacional para persistencia.

El propósito no es crear una aplicación compleja, sino **entender la separación de capas y su interacción**.

---

## Estructura del proyecto

La estructura de carpetas sigue la **Regla de la Dependencia**:  
las capas externas dependen de las internas, nunca al revés.

```bash
/src
├── core/            # Círculo interno: entidades y reglas de negocio
├── application/     # Círculo medio: casos de uso y lógica de aplicación
├── infrastructure/  # Círculo externo: implementaciones técnicas
└── presentation/    # Círculo externo: controladores y entrada/salida
```
Cada carpeta tiene un propósito claro. A continuación se describe cada una.

# Capa Core (Dominio)

Contiene la **lógica de negocio pura** y **no depende de ninguna otra capa**.

### Estructura

- **`core/entities`**
  Clases que representan los objetos de negocio fundamentales.  
  **Ejemplo:** `user.entity.ts`, `post.entity.ts`.

- **`core/repositories`**  
  Interfaces que definen cómo comunicarse con la capa de datos.  
  **Ejemplo:** `user.repository.interface.ts` con métodos como `findById`, `save`, `delete`.

- **`core/value-objects`**  
  Objetos que encapsulan valores y validaciones.  
  **Ejemplo:** `email.vo.ts` garantiza que un string sea un email válido.

- **`core/exceptions`**  
  Excepciones personalizadas del dominio.  
  **Ejemplo:** `domain-exceptions.ts` con `UserNotFoundException`.

---

# Capa Application (Casos de Uso)

Orquesta el flujo de datos entre las entidades (**core**) y las capas externas.

### Estructura

- **`application/commands`**  
  Acciones que modifican el estado del sistema (crear, actualizar, eliminar).  
  **Ejemplo:** `create-user.command.ts` coordina la creación de un usuario.

- **`application/queries`**  
  Acciones que leen datos sin modificarlos.  
  **Ejemplo:** `get-user.query.ts`.

- **`application/dtos`**  
  Objetos simples que transportan datos entre capas.  
  **Ejemplo:** `create-user.dto.ts`.

- **`application/mappers`**  
  Transforman entidades en DTOs o viceversa.  
  **Ejemplo:** `user.mapper.ts`.

---

# Capa Infrastructure (Implementaciones)

Contiene las **implementaciones concretas** definidas en el dominio.

### Estructura

- **`infrastructure/repositories`**  
  Implementaciones de los repositorios definidos en el core.  
  **Ejemplo:** `user.repository.ts` usa Prisma para persistir datos.

- **`infrastructure/database`**  
  Configuración y conexión a la base de datos.  
  **Ejemplo:** `prisma.service.ts`.

- **`infrastructure/logger`**, **`infrastructure/config`**  
  Servicios de soporte (logging, configuración, etc.).

---

# Capa Presentation (Puerta de Entrada)

Responsable de interactuar con el **mundo exterior**, como una API REST.

### Estructura

- **`presentation/modules`**  
  Módulos de NestJS que agrupan controladores y proveedores.

- **`presentation/modules/user/user.controller.ts`**  
  El controlador recibe solicitudes HTTP, valida los datos (DTOs), llama al caso de uso correspondiente y devuelve la respuesta.  
  El controlador **no contiene lógica de negocio**, solo orquesta el flujo entre el cliente y la aplicación.

---

# Flujo de una Solicitud: Creando un Usuario

Ejemplo de flujo para una solicitud `POST /users`:

1. **Presentation:**  
   El controlador `user.controller.ts` recibe la solicitud y valida los datos con `CreateUserDto`.

2. **Controller → Application:**  
   Invoca el `CreateUserCommand` de la capa `application`, pasando el DTO.

3. **Application:**  
   - Usa objetos de valor (`core`) para validar datos.  
   - Crea una instancia de `User` (entidad).  
   - Llama a `save()` del `UserRepositoryInterface`.

4. **Dependency Injection (NestJS):**  
   NestJS inyecta la implementación concreta (`user.repository.ts` de `infrastructure`).

5. **Infrastructure:**  
   El repositorio usa Prisma para escribir los datos en la base de datos.

6. **Retorno:**  
   La entidad creada se transforma a un DTO de respuesta y se devuelve al cliente.

---

# Conclusión

**Clean Architecture en NestJS** ofrece grandes ventajas:

- **Testabilidad:** puedes probar la lógica de negocio sin base de datos ni servidor.  
- **Independencia:** el dominio no depende de frameworks o herramientas.  
- **Mantenibilidad:** las responsabilidades están claramente separadas y el código es más fácil de entender, depurar y extender.

Aunque requiere una inversión inicial mayor, los beneficios en **escalabilidad y calidad del software** compensan ampliamente el esfuerzo en proyectos medianos o grandes.
