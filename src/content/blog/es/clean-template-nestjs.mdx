---
title: 'Arquitectura limpia en Nest JS'
date: 2025-07-27
description: 'Una plantilla de una aplicaciÃ³n NestJS que implementa Clean Architecture, un ejemplo prÃ¡ctico del poder de esta arquitectura.'
author: Alan LB
image: 'images/clean-architecture-nestjs.webp'
tags: [NestJS, Clean Architecture, Template Projects, Backend, NestJS, Software Architecture]
isDraft: false
---

# IntroducciÃ³n

En este artÃ­culo presento un anÃ¡lisis sobre los pros y contras de implementar Clean Architecture en una soluciÃ³n de software. TambiÃ©n incluyo un showcase prÃ¡ctico utilizando NestJS, con el objetivo de ilustrar cÃ³mo este enfoque puede aplicarse en un entorno real y quÃ© implicaciones tiene en el diseÃ±o y mantenimiento de un proyecto.

MÃ¡s que ofrecer una guÃ­a paso a paso, mi intenciÃ³n es reflexionar sobre las decisiones arquitectÃ³nicas que surgen al aplicar Clean Architecture, y mostrar cÃ³mo puede influir en la escalabilidad, la mantenibilidad y la claridad del cÃ³digo.

---

# QuÃ© es Clean Architecture

Clean Architecture es un patrÃ³n de diseÃ±o de software que busca separar las responsabilidades dentro de una aplicaciÃ³n y mantener su independencia respecto a frameworks, bases de datos o librerÃ­as externas.

En esencia, propone que el nÃºcleo del negocio â€”las reglas y la lÃ³gica que realmente definen el sistemaâ€” estÃ© completamente aislado de los detalles de implementaciÃ³n.

Esto significa que si maÃ±ana decides cambiar la base de datos, una dependencia o incluso el framework completo, no deberÃ­as tener que reescribir la mayor parte del proyecto.

Clean Architecture promueve flexibilidad, mantenibilidad y escalabilidad, aunque implica un mayor esfuerzo inicial de aprendizaje y diseÃ±o para aplicarla correctamente.

---

# Ventajas y desventajas de Clean Architecture

Como todo enfoque de diseÃ±o, Clean Architecture ofrece beneficios claros, pero tambiÃ©n presenta ciertos costos que conviene considerar antes de adoptarla.

---

### Ventajas

- **CÃ³digo modular y mantenible**: las responsabilidades estÃ¡n bien definidas, lo que facilita comprender, extender y modificar el sistema.

- **Testing mÃ¡s simple y confiable**: al aislar las reglas de negocio, las pruebas unitarias pueden realizarse sin depender de frameworks ni bases de datos.

- **Independencia tecnolÃ³gica**: permite reemplazar frameworks, librerÃ­as o fuentes de datos sin afectar la lÃ³gica central del negocio.

- **Escalabilidad estructurada**: la arquitectura soporta el crecimiento del proyecto sin volverse inmanejable.

---

### Desventajas

- **Complejidad inicial mÃ¡s alta**: requiere una planificaciÃ³n cuidadosa y una comprensiÃ³n sÃ³lida de sus principios antes de implementarla correctamente.

- **Curva de aprendizaje pronunciada**: para equipos nuevos o pequeÃ±os, puede representar una inversiÃ³n considerable de tiempo.

- **Sobrecarga en proyectos simples**: para aplicaciones con vida corta o alcance limitado, puede ser una soluciÃ³n mÃ¡s compleja de lo necesario.


En resumen, **Clean Architecture cobra verdadero sentido cuando un proyecto busca evolucionar, escalar o mantenerse a largo plazo**. En cambio, para un prototipo o un producto con alto grado de incertidumbre, una arquitectura mÃ¡s simple puede ser una decisiÃ³n mÃ¡s prÃ¡ctica.

---

# Capas de Clean Architecture

Aunque los nombres pueden variar segÃºn el proyecto, el principio clave es siempre el mismo: **separar responsabilidades y mantener el dominio independiente de los detalles tÃ©cnicos**. Una estructura tÃ­pica en **NestJS** puede verse asÃ­:

```bash
ğŸ“¦src
 â”£ ğŸ“‚application              â†’ LÃ³gica de casos de uso (CQRS, DTOs, mappers)
 â”ƒ â”£ ğŸ“‚commands
 â”ƒ â”£ ğŸ“‚queries
 â”ƒ â”£ ğŸ“‚dtos
 â”ƒ â”— ğŸ“‚mappers
 â”£ ğŸ“‚core                     â†’ Dominio puro (entidades, VOs, servicios de dominio)
 â”ƒ â”£ ğŸ“‚entities
 â”ƒ â”£ ğŸ“‚value-objects
 â”ƒ â”£ ğŸ“‚repositories           â†’ Contratos (interfaces)
 â”ƒ â”— ğŸ“‚services               â†’ Reglas de negocio puras
 â”£ ğŸ“‚infrastructure           â†’ Implementaciones tÃ©cnicas
 â”ƒ â”£ ğŸ“‚database               â†’ ORMs / conexiÃ³n
 â”ƒ â”£ ğŸ“‚repositories           â†’ Repositorios concretos
 â”ƒ â”£ ğŸ“‚logger                 â†’ Infra de logs
 â”ƒ â”£ ğŸ“‚services               â†’ Servicios de infraestructura
 â”ƒ â”— ğŸ“‚config                 â†’ ConfiguraciÃ³n del proyecto
 â”£ ğŸ“‚presentation             â†’ Capa API (controllers, guards, modules)
 â”ƒ â”£ ğŸ“‚modules
 â”ƒ â”— ğŸ“‚guards
 â”£ ğŸ“‚shared                  â†’ Cosas transversales (decorators, constants)
 â”— ğŸ“œapp.module.ts
```
En las siguientes secciones, cada capa se explicarÃ¡ con mÃ¡s detalle, junto con una breve descripciÃ³n de lo que contiene y cÃ³mo contribuye a la arquitectura general.


# La Capa de Dominio (Core)

La capa de **core** â€”tambiÃ©n llamada *capa de Dominio*â€” es el corazÃ³n de la aplicaciÃ³n. Contiene la lÃ³gica de negocio, las reglas del dominio y todas las decisiones que definen cÃ³mo debe comportarse el sistema.  
Es completamente independiente de tecnologÃ­as externas como frameworks, bases de datos o cualquier servicio de infraestructura.

El propÃ³sito de esta capa es ser **estable**, **reutilizable** y **agnÃ³stica a la tecnologÃ­a**, de modo que la complejidad del negocio estÃ© encapsulada y protegida del resto del sistema.

---

## Estructura de `src/core`

## `entities/`

Las **entidades** representan los objetos fundamentales del dominio. Se caracterizan por tener **identidad propia**, que se mantiene en el tiempo independientemente de sus atributos.

En este ejemplo, contamos con dos entidades principales:

- `user.entity.ts`: Representa a un usuario dentro del sistema.  
- `post.entity.ts`: Representa una publicaciÃ³n creada por un usuario.

Cada entidad encapsula atributos y comportamientos esenciales para su rol en el dominio.

---

## `value-objects/`

Los **Value Objects** representan conceptos del dominio que **no tienen identidad propia**. Son **inmutables**, y dos Value Objects son iguales si sus valores internos coinciden.

Ejemplos del proyecto:

- `email.vo.ts`: Encapsula la validaciÃ³n y el formato de un correo electrÃ³nico.  
- `name.vo.ts`: Define reglas para el nombre de un usuario (longitud, formato, etc.).  
- `throttle-limit.vo.ts`: Representa un lÃ­mite de uso o nÃºmero mÃ¡ximo de peticiones.

Utilizar Value Objects aporta **robustez**, **coherencia** y evita que datos invÃ¡lidos entren en el dominio.

---

## `repositories/`

AquÃ­ no se implementan repositorios; **solo se definen sus interfaces**.  
Este diseÃ±o evita que el dominio dependa de una base de datos especÃ­fica o tecnologÃ­a de persistencia.

Ejemplos:

- `user.repository.interface.ts`: Define mÃ©todos como `findById`, `findByEmail`, `create`, `update`, etc.  
- `post.repository.interface.ts`: Contratos para la persistencia de publicaciones.

Las implementaciones reales viven en la capa de **infrastructure**, manteniendo aislado al dominio.

---

## `services/`

Los **servidores de dominio** coordinan reglas de negocio que involucran entidades, Value Objects y repositorios.  
TambiÃ©n encapsulan lÃ³gica que no pertenece enteramente a una sola entidad.

Ejemplos:

- `user.service.ts`: Maneja la creaciÃ³n y actualizaciÃ³n de usuarios, validaciones complejas y reglas transversales.  
  Utiliza Value Objects (`Email`, `FirstName`, `LastName`) para garantizar datos vÃ¡lidos en el dominio.
- `post.service.ts`: LÃ³gica relacionada con publicaciones que no corresponde exclusivamente a la entidad `Post`.  
- `throttler.service.ts`: Define las reglas del dominio para gestionar lÃ­mites de peticiones.

---

## `exceptions/`

AquÃ­ se definen las **excepciones del dominio**, usadas para representar errores de negocio de forma clara y consistente.

Incluyen:

- **`DomainException`**: Clase base para todas las excepciones del dominio.  
- **`EntityNotFoundException`**: Cuando una entidad no existe.  
- **`EntityAlreadyExistsException`**: Cuando una entidad ya estÃ¡ registrada.  
- **`InvalidValueObjectException`**: Para valores invÃ¡lidos en Value Objects.  
- **Excepciones de throttling**: Cuando se violan reglas de lÃ­mites de peticiones.

Estas excepciones permiten identificar rÃ¡pidamente el origen y tipo de error sin depender de excepciones genÃ©ricas.

---

# La Capa de AplicaciÃ³n (Application)

La capa de **application** define los *casos de uso* de la aplicaciÃ³n. Su funciÃ³n principal es coordinar el flujo entre la entrada de datos y el dominio, sin contener reglas de negocio internas.

En otras palabras, aquÃ­ se decide **quÃ© se hace**, pero no **cÃ³mo funciona la lÃ³gica interna**, ya que eso vive en la capa de `core`.

Esta capa es muy ligera en este proyecto, pues busca ser un ejemplo simple y fÃ¡cil de entender.

---

## Estructura de `src/application`

### `commands/`
Los **Commands** representan operaciones que modifican el sistema, como crear o actualizar un usuario.  
Cada comando tiene un *handler* que ejecuta el caso de uso llamando a los servicios del dominio.

Ejemplo:
- `create-user.command.ts`

---

### `queries/`
Las **Queries** representan operaciones de lectura.  
No cambian el estado; solo obtienen informaciÃ³n desde el dominio o repositorios.

Ejemplo:
- `get-user.query.ts`

---

### `dtos/`
Los DTOs definen la forma de los datos que entran o salen de la aplicaciÃ³n.  
Aseguran que la capa de aplicaciÃ³n sea independiente del dominio y de detalles externos.

Ejemplos:
- `create-user.dto.ts`
- `responses/user.response.ts`

---

### `mappers/`
Los **mappers** transforman objetos del dominio en DTOs de salida.  
Esto mantiene el dominio limpio y evita exponer detalles internos.

Ejemplo:
- `user.mapper.ts`

---

## En resumen

La capa de **application**:
- coordina casos de uso,
- separa lectura y escritura (Commands / Queries),
- valida y estructura datos con DTOs,
- transforma entidades en respuestas mediante mappers.

Su objetivo es mantener el dominio limpio y exponer un flujo claro y ordenado para cada operaciÃ³n del sistema.

---

# La Capa de Infrastructure

La capa de **Infrastructure** es donde las abstracciones del dominio se conectan con tecnologÃ­as reales. Mientras el **core** define *quÃ©* debe hacerse, esta capa define *cÃ³mo* se realiza utilizando herramientas concretas como Prisma, servicios externos, logging o mÃ³dulos de configuraciÃ³n.

AquÃ­ se materializa la InversiÃ³n de Dependencias: las capas superiores dependen de interfaces, y **solo Infrastructure conoce las implementaciones reales**.

---

## Estructura de `src/infrastructure`

### `repositories/`
Implementaciones concretas de los repositorios definidos en el dominio.

- **`user.repository.ts`**  
  Implementa `IUserRepository` usando Prisma. Ejecuta consultas reales y transforma resultados en entidades de dominio.

- **`post.repository.ts`**  
  Persistencia concreta de la entidad `Post`.

- **`base.repository.ts`**  
  Funcionalidades compartidas (manejo de errores, helpers).

---

### `database/`
ConfiguraciÃ³n y acceso a la base de datos.

- **`prisma.service.ts`** Envuelve `PrismaClient` y lo expone a la aplicaciÃ³n.

- **`prisma.module.ts`**  
  MÃ³dulo que ofrece el servicio de Prisma mediante inyecciÃ³n de dependencias.

---

### `services/`
Servicios con dependencias tecnolÃ³gicas.

- **`throttler.service.ts`**  
  ImplementaciÃ³n de rate-limiting basada en infraestructura (por ejemplo, en memoria o Redis).

---

### `config/`
AdministraciÃ³n de variables de entorno y parÃ¡metros de configuraciÃ³n.

- **`configuration.ts`**  
  Carga, valida y expone variables de entorno usando `@nestjs/config`.

---

### `logger/`
Implementaciones concretas para logging.

- **`logger.interface.ts`**  
  Contrato abstracto para cualquier logger.

- **`logger.service.ts`**  
  ImplementaciÃ³n concreta (desde `console.log` hasta proveedores como Sentry o Datadog).

---

# La Capa de PresentaciÃ³n (Presentation)

La capa de `presentation` es la cara externa de la aplicaciÃ³n. Es el punto de entrada y salida para todas las interacciones con los clientes (web, mÃ³viles u otros servicios). En este proyecto, esta capa implementa una **API REST** utilizando **NestJS**.

Su responsabilidad principal es manejar el **protocolo HTTP**, lo que incluye:

- Definir rutas y endpoints.
- Manejar verbos HTTP (GET, POST, PUT, DELETE, etc.).
- Procesar y validar datos de entrada (body, params, query).
- Delegar la ejecuciÃ³n de casos de uso hacia la capa `application`.
- Formatear datos de salida y establecer cÃ³digos de estado HTTP.

Esta capa debe ser **delgada**: no contiene lÃ³gica de negocio. Su funciÃ³n es recibir una peticiÃ³n, delegarla y devolver la respuesta.

---

## Estructura de `src/presentation`

### `modules`

En NestJS, los mÃ³dulos agrupan funcionalidades relacionadas. En esta capa, cada mÃ³dulo contiene sus controladores y dependencias.

- **`user/user.controller.ts`**  
  El controlador define los endpoints de usuario, por ejemplo:
  - `@Post()` para crear un usuario.
  - `@Get(':id')` para obtener un usuario por ID.

  Utiliza decoradores como `@Body()` o `@Param()` para extraer datos de la peticiÃ³n y validarlos mediante DTOs.

  Su Ãºnica lÃ³gica es delegar a la capa de aplicaciÃ³n mediante `CommandBus` o `QueryBus`.

- **`user/user.module.ts`**  
  Encapsula el controlador y registra sus dependencias. Puede importar otros mÃ³dulos necesarios.

---

## `guards`

Los Guards determinan si una peticiÃ³n debe continuar. Son ideales para autenticaciÃ³n, autorizaciÃ³n o protecciÃ³n de endpoints.

- **`throttler.guard.ts`**  
  Implementa limitaciÃ³n de tasa (rate limiting). Intercepta peticiones antes del controlador y decide si se excediÃ³ el nÃºmero permitido de solicitudes.

---

## Decoradores (`src/shared/decorators`)

Aunque no siempre viven dentro de `presentation`, suelen utilizarse ahÃ­.

- **`throttle.decorator.ts`**  
  Permite aplicar rate limiting de forma declarativa, por ejemplo:  
  `@Throttle(60, 5)` â†’ 5 peticiones cada 60 segundos.

---

## Flujo de una PeticiÃ³n HTTP

1. **PeticiÃ³n entrante:** un cliente envÃ­a `POST /users` con un cuerpo JSON.
2. **Enrutamiento:** NestJS dirige la peticiÃ³n al mÃ©todo del controlador decorado con `@Post()`.
3. **Guards:** se ejecuta el `ThrottlerGuard`.  
   Si se excede el lÃ­mite â†’ responde `429 Too Many Requests`.
4. **ValidaciÃ³n:** el decorador `@Body()` valida la estructura del JSON contra `CreateUserDto`.  
   Si falla â†’ responde `400 Bad Request`.
5. **DelegaciÃ³n a Application:** el controlador ejecuta:  
   `this.commandBus.execute(new CreateUserCommand(dto))`.
6. **Procesamiento interno:** `application`, `core` e `infrastructure` realizan el trabajo.
7. **Respuesta:** el controlador devuelve el resultado.  
   NestJS serializa la respuesta a JSON y envÃ­a el cÃ³digo HTTP adecuado (`201` en POST, `200` en GET).

---

# ConclusiÃ³n y Repositorio del Proyecto

Clean Architecture no es solo una forma de estructurar archivos: es una filosofÃ­a que promueve claridad, mantenibilidad y evoluciÃ³n a largo plazo. Aunque al inicio puede parecer mÃ¡s compleja que otras alternativas, sus beneficios se hacen evidentes cuando el proyecto crece, se vuelve mÃ¡s modular y necesita adaptarse a nuevas tecnologÃ­as sin romper su nÃºcleo.

Si deseas ver una implementaciÃ³n completa basada en lo explicado en este artÃ­culo, te invito a revisar el repositorio del proyecto:

**Repositorio en GitHub:**  
[https://github.com/alanlb195/clean-architecture-template](https://github.com/alanlb195/clean-template-nest)

En este repositorio encontrarÃ¡s la estructura completa, ejemplos reales, casos de uso, repositorios, servicios y todo lo necesario para utilizar esta plantilla como base en tus propios desarrollos con NestJS.
