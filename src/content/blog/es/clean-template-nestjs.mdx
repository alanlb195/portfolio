---
title: 'Arquitectura limpia en Nest JS'
date: 2025-07-27
description: 'Una plantilla de una aplicacion nest js que implementa Clean Architecture, un ejemplo practico del poder de clean architecture.'
author: Alan LB
image: 'images/clean-architecture-nestjs.webp'
tags: [NestJS, Clean Architecture, Template Projects, Backend, Nest js, Software Architecture]
isDraft: false
---
# üß± Introducci√≥n

¬°Hola, devs! üëã  
Hoy no vengo a contarte la historia √©pica de Clean Architecture ni a repetir lo que ya se ha dicho mil veces.  
Mi objetivo es **ser directo y cr√≠tico**, mostrarte **cu√°ndo realmente vale la pena aplicarla** y compartirte **una plantilla pr√°ctica con NestJS** para que no te pierdas en el intento üöÄ.

# üß© Qu√© es Clean Architecture

En pocas palabras, **Clean Architecture** es un enfoque de dise√±o de software que busca **separar responsabilidades** y mantener la **independencia** de frameworks, bases de datos o interfaces de usuario.

üëâ En otras palabras, si ma√±ana necesitas cambiar la base de datos, una dependencia o incluso el framework completo, **no deber√≠as tener que reescribir medio proyecto**.  
Ese nivel de flexibilidad y mantenibilidad es justo lo que esta arquitectura persigue üß†.

# ‚öñÔ∏è Pros y contras de implementar Clean Architecture

Como en casi todo en la vida, **nada es perfecto**.  
Si no est√°s dispuesto a asumir ciertos compromisos, quiz√°s Clean Architecture **no sea la mejor opci√≥n** para tu proyecto. Todo depende del **contexto** y de los **objetivos**.

üí° *Imagina esto:*  
Quieres comprar un celular.  
- Si solo lo usas para WhatsApp, llamadas y mensajes, un modelo econ√≥mico te basta.  
- Pero si eres desarrollador de videojuegos y necesitas potencia, herramientas y rendimiento‚Ä¶ ese mismo tel√©fono se queda corto.  

Con Clean Architecture pasa lo mismo: **depende del tipo de proyecto** y de lo que esperas de √©l.

En un proyecto t√≠pico con **NestJS**, solemos trabajar con una estructura modular (similar a Angular, aunque no id√©ntica).  
Cada m√≥dulo representa una funcionalidad ‚Äîpor ejemplo, `Users`, `Posts`, etc.‚Äî y puede ser reutilizado en otros mediante **inyecci√≥n de dependencias**. Esa es la filosof√≠a NestJS.

üß† Pero Clean Architecture va un paso m√°s all√°: busca que tu aplicaci√≥n **no dependa del framework**, sino que el framework **dependa de tu aplicaci√≥n**.  
Esto se logra separando las responsabilidades en capas bien definidas que hacen tu c√≥digo m√°s **flexible, escalable y f√°cil de mantener** a largo plazo.

# üèóÔ∏è Capas de Clean Architecture

Los nombres pueden variar seg√∫n el proyecto, pero el principio base es el mismo:  
**separar responsabilidades y mantener el dominio completamente independiente de los detalles t√©cnicos.**

Una forma pr√°ctica de estructurarlo en **NestJS** es la siguiente:

---

### üß† Domain (o Core)

Aqu√≠ vive **el coraz√≥n del negocio**, totalmente libre de frameworks o librer√≠as externas.

Incluye:
- Entidades que representan los conceptos principales del dominio.  
- Reglas de negocio y validaciones puras.  

üí° **Objetivo:** Que esta capa pueda funcionar sin importar si usas NestJS, Express o cualquier otro framework.

---

### ‚öôÔ∏è Application (o Use Cases)

Define **qu√© hace tu sistema** y **c√≥mo interact√∫an las partes internas** del dominio con el exterior.

Contiene:
- Casos de uso que orquestan la l√≥gica de negocio.  
- Interfaces o puertos que la infraestructura deber√° implementar (como repositorios).  

üí° **Objetivo:** Contener la l√≥gica de aplicaci√≥n sin depender de implementaciones concretas de base de datos o transporte HTTP.

---

### üß© Infrastructure

Aqu√≠ entran todas las **implementaciones t√©cnicas concretas**.

Incluye:
- Adaptadores de persistencia (repositorios que implementan los puertos del dominio).  
- Integraciones con APIs externas, ORM, servicios de mensajer√≠a, etc.  
- Configuraci√≥n espec√≠fica de NestJS.  

üí° **Objetivo:** Si ma√±ana decides cambiar de ORM (por ejemplo, de TypeORM a Prisma), solo deber√≠as tocar esta capa üòé.

---

### üåê Presentation (o Interface Adapters)

Es la **puerta de entrada** del mundo exterior a tu aplicaci√≥n.

Incluye:
- Controladores o resolvers (REST, GraphQL, gRPC‚Ä¶).  
- DTOs y validaciones de entrada/salida.  

üí° **Objetivo:** Exponer tu l√≥gica de aplicaci√≥n sin que las reglas de negocio conozcan los detalles t√©cnicos de c√≥mo llegan los datos.

---

# üöÄ Showcase: Arquitectura Limpia con NestJS

Basta de teor√≠a, ¬°vamos a la pr√°ctica! üí™  
Porque ‚Äîseamos sinceros‚Äî en el desarrollo, **la mejor forma de aprender es haciendo**.  
As√≠ que construyamos juntos un peque√±o proyecto en **NestJS** que ponga a prueba los principios de **Clean Architecture** y veamos c√≥mo se traduce todo esto en c√≥digo real.

## üß∞ Tecnolog√≠as utilizadas

En este showcase usaremos un stack sencillo pero s√≥lido:

- üü¶ **TypeScript** ‚Üí Para mantener un tipado fuerte en todas las capas (especialmente en el dominio).  
- ‚öôÔ∏è **NestJS** ‚Üí Como framework principal para estructurar la capa de presentaci√≥n.  
- üß† **Prisma ORM** ‚Üí Para comunicarnos con la base de datos de manera elegante y tipada.  
- üêò **PostgreSQL** (en un contenedor Docker) ‚Üí Nuestra base de datos relacional para persistir la informaci√≥n.  

La aplicaci√≥n ser√° una **demo sencilla**, con algunos endpoints que permiten **consultar informaci√≥n de usuarios**, pero el objetivo no es la funcionalidad, sino **entender la arquitectura y su prop√≥sito** üß©.

---

## üóÇÔ∏è Mapeo de la Arquitectura a Nuestro Proyecto

Nuestra estructura de carpetas refleja las **capas de Clean Architecture**, siguiendo la famosa **Regla de la Dependencia** (las capas externas dependen de las internas, ¬°nunca al rev√©s! üîÑ).

```bash
/src
‚îú‚îÄ‚îÄ core/            # üß† C√≠rculo Interno: Entidades y Reglas de Negocio
‚îú‚îÄ‚îÄ application/     # ‚öôÔ∏è C√≠rculo Medio: Casos de Uso y L√≥gica de Aplicaci√≥n
‚îú‚îÄ‚îÄ infrastructure/  # üß© C√≠rculo Externo: Implementaciones y Detalles T√©cnicos
‚îî‚îÄ‚îÄ presentation/    # üåê C√≠rculo Externo: Entrada/Salida (Controllers)
```
Cada carpeta representa una capa del sistema, y cada capa tiene un prop√≥sito claro.
Veamos c√≥mo se traduce esto en la pr√°ctica üëá

2.1. Capa core (El Coraz√≥n de la Aplicaci√≥n)

Esta es la capa m√°s interna y la m√°s importante. Contiene la l√≥gica de negocio pura y no depende de ninguna otra capa.

- `core/entities`: Representan los objetos de negocio fundamentales. Son clases simples que encapsulan datos y l√≥gica de negocio que es v√°lida en toda la
    empresa.
    - Ejemplo: user.entity.ts, post.entity.ts. Un User siempre tendr√° un nombre y un email, sin importar la tecnolog√≠a que usemos.

- `core/repositories`: Definen interfaces (contratos) que dictan c√≥mo se debe comunicar la aplicaci√≥n con la capa de datos. No contienen c√≥digo de
    implementaci√≥n.
    - Ejemplo: user.repository.interface.ts. Define m√©todos como findById, save, delete, pero no dice c√≥mo se implementan. Esto nos permite cambiar de
        Prisma a TypeORM sin tocar el core o la application.

- `core/value-objects`: Peque√±os objetos que representan un valor simple, como Email o Name. Encapsulan l√≥gica de validaci√≥n y garantizan que los datos
    dentro de una entidad sean siempre v√°lidos.
    - Ejemplo: email.vo.ts se asegura de que un string tenga el formato de un email v√°lido.

- `core/exceptions`: Excepciones personalizadas del dominio para manejar errores de negocio de forma expl√≠cita.
    - Ejemplo: domain-exceptions.ts podr√≠a contener un UserNotFoundException.

2.2. Capa application (Los Casos de Uso)

Esta capa orquesta el flujo de datos entre las entidades (core) y las capas externas. Contiene la l√≥gica espec√≠fica de la aplicaci√≥n (los "casos de uso").
Depende del core, pero no de infrastructure o presentation.

- `application/commands`: Representan acciones que modifican el estado del sistema (Crear, Actualizar, Eliminar). Siguen el patr√≥n CQRS (Command Query
    Responsibility Segregation).
    - Ejemplo: create-user.command.ts orquesta la creaci√≥n de un usuario. Recibe los datos, los valida y utiliza la interfaz del repositorio
        (UserRepositoryInterface) para persistir la entidad.

- `application/queries`: Representan acciones que leen el estado del sistema sin modificarlo.
    - Ejemplo: get-user.query.ts se encarga de obtener los datos de un usuario.

- `application/dtos`: (Data Transfer Objects) Son objetos simples que transportan datos entre capas, especialmente entre presentation y application. No
    tienen l√≥gica de negocio.
    - Ejemplo: create-user.dto.ts define la estructura de datos que el controlador env√≠a al caso de uso para crear un usuario.

- `application/mappers`: Convierten entidades del core a DTOs de respuesta, o viceversa.
    - Ejemplo: user.mapper.ts puede convertir un User (entidad) a un UserResponse (DTO) para evitar exponer la l√≥gica interna de la entidad a los clientes
        de la API.

2.3. Capa infrastructure (Las Implementaciones)

Esta es una capa externa. Contiene todas las implementaciones concretas de las interfaces definidas en el core. Es el mundo de las herramientas, frameworks
y tecnolog√≠as espec√≠ficas.

- `infrastructure/repositories`: Aqu√≠ es donde las interfaces del core cobran vida.
    - Ejemplo: user.repository.ts implementa UserRepositoryInterface usando Prisma. Si ma√±ana decidimos usar MongoDB, solo tendr√≠amos que crear un
        user.repository.mongodb.ts que implemente la misma interfaz, y el resto de la aplicaci√≥n seguir√≠a funcionando sin cambios.

- `infrastructure/database`: Configuraci√≥n y servicios relacionados con la base de datos.
    - Ejemplo: prisma.service.ts gestiona la conexi√≥n y el cliente de Prisma.

- `infrastructure/logger`, `infrastructure/config`: Implementaciones concretas para servicios como logging, configuraci√≥n, etc.

2.4. Capa presentation (La Puerta de Entrada)

Es la capa m√°s externa, responsable de interactuar con el "mundo exterior". En nuestro caso, es la API REST.

- `presentation/modules`: M√≥dulos de NestJS que agrupan controladores y proveedores.
- `presentation/modules/user/user.controller.ts`: El controlador es el punto de entrada de las solicitudes HTTP. Su √∫nica responsabilidad es:
    1. Recibir la solicitud.
    2. Extraer y validar los datos de entrada (usando DTOs).
    3. Llamar al caso de uso correspondiente en la capa application (un Command o un Query).
    4. Devolver la respuesta al cliente.
    Importante: El controlador no contiene l√≥gica de negocio. Es una capa muy delgada.

3. Flujo de una Solicitud: Creando un Usuario

Para consolidar el conocimiento, veamos el flujo completo de una solicitud POST /users:

1. Presentation: La solicitud llega al user.controller.ts. El @Body() de NestJS valida que los datos coincidan con CreateUserDto.
2. Controller -> Application: El controlador invoca el CreateUserCommand de la capa application, pas√°ndole el DTO.
3. Application: El manejador del comando:
    a. Recibe el CreateUserDto.
    b. Puede usar Value Objects (core) para validar y crear los componentes de la entidad (Name, Email).
    c. Crea una instancia de User (core/entities).
    d. Llama al m√©todo save() del UserRepositoryInterface (core/repositories).
4. Dependency Injection (Magia de NestJS): NestJS, gracias a la inyecci√≥n de dependencias, sabe que debe proporcionar la implementaci√≥n concreta
    (infrastructure/repositories/user.repository.ts) cuando se solicita la interfaz.
5. Infrastructure: El user.repository.ts recibe la entidad User y utiliza el cliente de Prisma para escribir los datos en la base de datos.
6. Retorno: La respuesta viaja de vuelta por las mismas capas. El repositorio puede devolver la entidad creada, el caso de uso la mapea a un DTO de respuesta
    y el controlador la env√≠a como respuesta HTTP 201.

# Conclusi√≥n

Esta arquitectura nos brinda enormes beneficios:

- Testabilidad: Podemos probar la l√≥gica de negocio (core y application) sin levantar una base de datos ni un servidor web.
- Independencia: El coraz√≥n de nuestra aplicaci√≥n no sabe nada sobre NestJS o Prisma. Podemos actualizarlos o cambiarlos con un impacto m√≠nimo.
- Mantenibilidad: Las responsabilidades est√°n claramente definidas, lo que hace que el c√≥digo sea m√°s f√°cil de entender, depurar y extender.