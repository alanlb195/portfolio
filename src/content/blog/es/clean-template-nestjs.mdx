---
title: 'Arquitectura limpia en Nest JS'
date: 2025-07-27
description: 'Una plantilla de una aplicaci√≥n NestJS que implementa Clean Architecture, un ejemplo pr√°ctico del poder de esta arquitectura.'
author: Alan LB
image: 'images/clean-architecture-nestjs.webp'
tags: [NestJS, Clean Architecture, Template Projects, Backend, NestJS, Software Architecture]
isDraft: false
---

# Introducci√≥n

En este art√≠culo presento un an√°lisis sobre los pros y contras de implementar Clean Architecture en una soluci√≥n de software. Tambi√©n incluyo un showcase pr√°ctico utilizando NestJS, con el objetivo de ilustrar c√≥mo este enfoque puede aplicarse en un entorno real y qu√© implicaciones tiene en el dise√±o y mantenimiento de un proyecto.

M√°s que ofrecer una gu√≠a paso a paso, mi intenci√≥n es reflexionar sobre las decisiones arquitect√≥nicas que surgen al aplicar Clean Architecture, y mostrar c√≥mo puede influir en la escalabilidad, la mantenibilidad y la claridad del c√≥digo.

---

# Qu√© es Clean Architecture

Clean Architecture es un patr√≥n de dise√±o de software que busca separar las responsabilidades dentro de una aplicaci√≥n y mantener su independencia respecto a frameworks, bases de datos o librer√≠as externas.

En esencia, propone que el n√∫cleo del negocio ‚Äîlas reglas y la l√≥gica que realmente definen el sistema‚Äî est√© completamente aislado de los detalles de implementaci√≥n.

Esto significa que si ma√±ana decides cambiar la base de datos, una dependencia o incluso el framework completo, no deber√≠as tener que reescribir la mayor parte del proyecto.

Clean Architecture promueve flexibilidad, mantenibilidad y escalabilidad, aunque implica un mayor esfuerzo inicial de aprendizaje y dise√±o para aplicarla correctamente.

---

# Ventajas y desventajas de Clean Architecture

Como todo enfoque de dise√±o, Clean Architecture ofrece beneficios claros, pero tambi√©n presenta ciertos costos que conviene considerar antes de adoptarla.

---

### Ventajas

- **C√≥digo modular y mantenible**: las responsabilidades est√°n bien definidas, lo que facilita comprender, extender y modificar el sistema.

- **Testing m√°s simple y confiable**: al aislar las reglas de negocio, las pruebas unitarias pueden realizarse sin depender de frameworks ni bases de datos.

- **Independencia tecnol√≥gica**: permite reemplazar frameworks, librer√≠as o fuentes de datos sin afectar la l√≥gica central del negocio.

- **Escalabilidad estructurada**: la arquitectura soporta el crecimiento del proyecto sin volverse inmanejable.

---

### Desventajas

- **Complejidad inicial m√°s alta**: requiere una planificaci√≥n cuidadosa y una comprensi√≥n s√≥lida de sus principios antes de implementarla correctamente.

- **Curva de aprendizaje pronunciada**: para equipos nuevos o peque√±os, puede representar una inversi√≥n considerable de tiempo.

- **Sobrecarga en proyectos simples**: para aplicaciones con vida corta o alcance limitado, puede ser una soluci√≥n m√°s compleja de lo necesario.


En resumen, **Clean Architecture cobra verdadero sentido cuando un proyecto busca evolucionar, escalar o mantenerse a largo plazo**. En cambio, para un prototipo o un producto con alto grado de incertidumbre, una arquitectura m√°s simple puede ser una decisi√≥n m√°s pr√°ctica.

---

# Capas de Clean Architecture

Aunque los nombres pueden variar seg√∫n el proyecto, el principio clave es siempre el mismo: **separar responsabilidades y mantener el dominio independiente de los detalles t√©cnicos**. Una estructura t√≠pica en **NestJS** puede verse as√≠:

```bash
üì¶src
 ‚î£ üìÇapplication              ‚Üí L√≥gica de casos de uso (CQRS, DTOs, mappers)
 ‚îÉ ‚î£ üìÇcommands
 ‚îÉ ‚î£ üìÇqueries
 ‚îÉ ‚î£ üìÇdtos
 ‚îÉ ‚îó üìÇmappers
 ‚î£ üìÇcore                     ‚Üí Dominio puro (entidades, VOs, servicios de dominio)
 ‚îÉ ‚î£ üìÇentities
 ‚îÉ ‚î£ üìÇvalue-objects
 ‚îÉ ‚î£ üìÇrepositories           ‚Üí Contratos (interfaces)
 ‚îÉ ‚îó üìÇservices               ‚Üí Reglas de negocio puras
 ‚î£ üìÇinfrastructure           ‚Üí Implementaciones t√©cnicas
 ‚îÉ ‚î£ üìÇdatabase               ‚Üí ORMs / conexi√≥n
 ‚îÉ ‚î£ üìÇrepositories           ‚Üí Repositorios concretos
 ‚îÉ ‚î£ üìÇlogger                 ‚Üí Infra de logs
 ‚îÉ ‚î£ üìÇservices               ‚Üí Servicios de infraestructura
 ‚îÉ ‚îó üìÇconfig                 ‚Üí Configuraci√≥n del proyecto
 ‚î£ üìÇpresentation             ‚Üí Capa API (controllers, guards, modules)
 ‚îÉ ‚î£ üìÇmodules
 ‚îÉ ‚îó üìÇguards
 ‚î£ üìÇshared                  ‚Üí Cosas transversales (decorators, constants)
 ‚îó üìúapp.module.ts
```
En las siguientes secciones, cada capa se explicar√° con m√°s detalle, junto con una breve descripci√≥n de lo que contiene y c√≥mo contribuye a la arquitectura general.


# La Capa de Dominio (Core)

La capa de **core** ‚Äîtambi√©n llamada *capa de Dominio*‚Äî es el coraz√≥n de la aplicaci√≥n. Contiene la l√≥gica de negocio, las reglas del dominio y todas las decisiones que definen c√≥mo debe comportarse el sistema.  
Es completamente independiente de tecnolog√≠as externas como frameworks, bases de datos o cualquier servicio de infraestructura.

El prop√≥sito de esta capa es ser **estable**, **reutilizable** y **agn√≥stica a la tecnolog√≠a**, de modo que la complejidad del negocio est√© encapsulada y protegida del resto del sistema.

---

## Estructura de `src/core`

## `entities/`

Las **entidades** representan los objetos fundamentales del dominio. Se caracterizan por tener **identidad propia**, que se mantiene en el tiempo independientemente de sus atributos.

En este ejemplo, contamos con dos entidades principales:

- `user.entity.ts`: Representa a un usuario dentro del sistema.  
- `post.entity.ts`: Representa una publicaci√≥n creada por un usuario.

Cada entidad encapsula atributos y comportamientos esenciales para su rol en el dominio.

---

## `value-objects/`

Los **Value Objects** representan conceptos del dominio que **no tienen identidad propia**. Son **inmutables**, y dos Value Objects son iguales si sus valores internos coinciden.

Ejemplos del proyecto:

- `email.vo.ts`: Encapsula la validaci√≥n y el formato de un correo electr√≥nico.  
- `name.vo.ts`: Define reglas para el nombre de un usuario (longitud, formato, etc.).  
- `throttle-limit.vo.ts`: Representa un l√≠mite de uso o n√∫mero m√°ximo de peticiones.

Utilizar Value Objects aporta **robustez**, **coherencia** y evita que datos inv√°lidos entren en el dominio.

---

## `repositories/`

Aqu√≠ no se implementan repositorios; **solo se definen sus interfaces**.  
Este dise√±o evita que el dominio dependa de una base de datos espec√≠fica o tecnolog√≠a de persistencia.

Ejemplos:

- `user.repository.interface.ts`: Define m√©todos como `findById`, `findByEmail`, `create`, `update`, etc.  
- `post.repository.interface.ts`: Contratos para la persistencia de publicaciones.

Las implementaciones reales viven en la capa de **infrastructure**, manteniendo aislado al dominio.

---

## `services/`

Los **servidores de dominio** coordinan reglas de negocio que involucran entidades, Value Objects y repositorios.  
Tambi√©n encapsulan l√≥gica que no pertenece enteramente a una sola entidad.

Ejemplos:

- `user.service.ts`: Maneja la creaci√≥n y actualizaci√≥n de usuarios, validaciones complejas y reglas transversales.  
  Utiliza Value Objects (`Email`, `FirstName`, `LastName`) para garantizar datos v√°lidos en el dominio.
- `post.service.ts`: L√≥gica relacionada con publicaciones que no corresponde exclusivamente a la entidad `Post`.  
- `throttler.service.ts`: Define las reglas del dominio para gestionar l√≠mites de peticiones.

---

## `exceptions/`

Aqu√≠ se definen las **excepciones del dominio**, usadas para representar errores de negocio de forma clara y consistente.

Incluyen:

- **`DomainException`**: Clase base para todas las excepciones del dominio.  
- **`EntityNotFoundException`**: Cuando una entidad no existe.  
- **`EntityAlreadyExistsException`**: Cuando una entidad ya est√° registrada.  
- **`InvalidValueObjectException`**: Para valores inv√°lidos en Value Objects.  
- **Excepciones de throttling**: Cuando se violan reglas de l√≠mites de peticiones.

Estas excepciones permiten identificar r√°pidamente el origen y tipo de error sin depender de excepciones gen√©ricas.

---

# La Capa de Aplicaci√≥n (Application)

La capa de **application** define los *casos de uso* de la aplicaci√≥n. Su funci√≥n principal es coordinar el flujo entre la entrada de datos y el dominio, sin contener reglas de negocio internas.

En otras palabras, aqu√≠ se decide **qu√© se hace**, pero no **c√≥mo funciona la l√≥gica interna**, ya que eso vive en la capa de `core`.

Esta capa es muy ligera en este proyecto, pues busca ser un ejemplo simple y f√°cil de entender.

---

## Estructura de `src/application`

### `commands/`
Los **Commands** representan operaciones que modifican el sistema, como crear o actualizar un usuario.  
Cada comando tiene un *handler* que ejecuta el caso de uso llamando a los servicios del dominio.

Ejemplo:
- `create-user.command.ts`

---

### `queries/`
Las **Queries** representan operaciones de lectura.  
No cambian el estado; solo obtienen informaci√≥n desde el dominio o repositorios.

Ejemplo:
- `get-user.query.ts`

---

### `dtos/`
Los DTOs definen la forma de los datos que entran o salen de la aplicaci√≥n.  
Aseguran que la capa de aplicaci√≥n sea independiente del dominio y de detalles externos.

Ejemplos:
- `create-user.dto.ts`
- `responses/user.response.ts`

---

### `mappers/`
Los **mappers** transforman objetos del dominio en DTOs de salida.  
Esto mantiene el dominio limpio y evita exponer detalles internos.

Ejemplo:
- `user.mapper.ts`

---

## En resumen

La capa de **application**:
- coordina casos de uso,
- separa lectura y escritura (Commands / Queries),
- valida y estructura datos con DTOs,
- transforma entidades en respuestas mediante mappers.

Su objetivo es mantener el dominio limpio y exponer un flujo claro y ordenado para cada operaci√≥n del sistema.

---

# La Capa de Infrastructure

La capa de **Infrastructure** es donde las abstracciones del dominio se conectan con tecnolog√≠as reales. Mientras el **core** define *qu√©* debe hacerse, esta capa define *c√≥mo* se realiza utilizando herramientas concretas como Prisma, servicios externos, logging o m√≥dulos de configuraci√≥n.

Aqu√≠ se materializa la Inversi√≥n de Dependencias: las capas superiores dependen de interfaces, y **solo Infrastructure conoce las implementaciones reales**.

---

## Estructura de `src/infrastructure`

### `repositories/`
Implementaciones concretas de los repositorios definidos en el dominio.

- **`user.repository.ts`**  
  Implementa `IUserRepository` usando Prisma. Ejecuta consultas reales y transforma resultados en entidades de dominio.

- **`post.repository.ts`**  
  Persistencia concreta de la entidad `Post`.

- **`base.repository.ts`**  
  Funcionalidades compartidas (manejo de errores, helpers).

---

### `database/`
Configuraci√≥n y acceso a la base de datos.

- **`prisma.service.ts`** Envuelve `PrismaClient` y lo expone a la aplicaci√≥n.

- **`prisma.module.ts`**  
  M√≥dulo que ofrece el servicio de Prisma mediante inyecci√≥n de dependencias.

---

### `services/`
Servicios con dependencias tecnol√≥gicas.

- **`throttler.service.ts`**  
  Implementaci√≥n de rate-limiting basada en infraestructura (por ejemplo, en memoria o Redis).

---

### `config/`
Administraci√≥n de variables de entorno y par√°metros de configuraci√≥n.

- **`configuration.ts`**  
  Carga, valida y expone variables de entorno usando `@nestjs/config`.

---

### `logger/`
Implementaciones concretas para logging.

- **`logger.interface.ts`**  
  Contrato abstracto para cualquier logger.

- **`logger.service.ts`**  
  Implementaci√≥n concreta (desde `console.log` hasta proveedores como Sentry o Datadog).

---

# La Capa de Presentaci√≥n (Presentation)

La capa de `presentation` es la cara externa de la aplicaci√≥n. Es el punto de entrada y salida para todas las interacciones con los clientes (web, m√≥viles u otros servicios). En este proyecto, esta capa implementa una **API REST** utilizando **NestJS**.

Su responsabilidad principal es manejar el **protocolo HTTP**, lo que incluye:

- Definir rutas y endpoints.
- Manejar verbos HTTP (GET, POST, PUT, DELETE, etc.).
- Procesar y validar datos de entrada (body, params, query).
- Delegar la ejecuci√≥n de casos de uso hacia la capa `application`.
- Formatear datos de salida y establecer c√≥digos de estado HTTP.

Esta capa debe ser **delgada**: no contiene l√≥gica de negocio. Su funci√≥n es recibir una petici√≥n, delegarla y devolver la respuesta.

---

## Estructura de `src/presentation`

### `modules`

En NestJS, los m√≥dulos agrupan funcionalidades relacionadas. En esta capa, cada m√≥dulo contiene sus controladores y dependencias.

- **`user/user.controller.ts`**  
  El controlador define los endpoints de usuario, por ejemplo:
  - `@Post()` para crear un usuario.
  - `@Get(':id')` para obtener un usuario por ID.

  Utiliza decoradores como `@Body()` o `@Param()` para extraer datos de la petici√≥n y validarlos mediante DTOs.

  Su √∫nica l√≥gica es delegar a la capa de aplicaci√≥n mediante `CommandBus` o `QueryBus`.

- **`user/user.module.ts`**  
  Encapsula el controlador y registra sus dependencias. Puede importar otros m√≥dulos necesarios.

---

## `guards`

Los Guards determinan si una petici√≥n debe continuar. Son ideales para autenticaci√≥n, autorizaci√≥n o protecci√≥n de endpoints.

- **`throttler.guard.ts`**  
  Implementa limitaci√≥n de tasa (rate limiting). Intercepta peticiones antes del controlador y decide si se excedi√≥ el n√∫mero permitido de solicitudes.

---

## Decoradores (`src/shared/decorators`)

Aunque no siempre viven dentro de `presentation`, suelen utilizarse ah√≠.

- **`throttle.decorator.ts`**  
  Permite aplicar rate limiting de forma declarativa, por ejemplo:  
  `@Throttle(60, 5)` ‚Üí 5 peticiones cada 60 segundos.

---

## Flujo de una Petici√≥n HTTP

1. **Petici√≥n entrante:** un cliente env√≠a `POST /users` con un cuerpo JSON.
2. **Enrutamiento:** NestJS dirige la petici√≥n al m√©todo del controlador decorado con `@Post()`.
3. **Guards:** se ejecuta el `ThrottlerGuard`.  
   Si se excede el l√≠mite ‚Üí responde `429 Too Many Requests`.
4. **Validaci√≥n:** el decorador `@Body()` valida la estructura del JSON contra `CreateUserDto`.  
   Si falla ‚Üí responde `400 Bad Request`.
5. **Delegaci√≥n a Application:** el controlador ejecuta:  
   `this.commandBus.execute(new CreateUserCommand(dto))`.
6. **Procesamiento interno:** `application`, `core` e `infrastructure` realizan el trabajo.
7. **Respuesta:** el controlador devuelve el resultado.  
   NestJS serializa la respuesta a JSON y env√≠a el c√≥digo HTTP adecuado (`201` en POST, `200` en GET).

---

# Conclusi√≥n y Repositorio del Proyecto

Clean Architecture no es solo una forma de estructurar archivos: es una filosof√≠a que promueve claridad, mantenibilidad y evoluci√≥n a largo plazo. Aunque al inicio puede parecer m√°s compleja que otras alternativas, sus beneficios se hacen evidentes cuando el proyecto crece, se vuelve m√°s modular y necesita adaptarse a nuevas tecnolog√≠as sin romper su n√∫cleo.

Si deseas ver una implementaci√≥n completa basada en lo explicado en este art√≠culo, te invito a revisar el repositorio del proyecto:

**Repositorio en GitHub:**  
[https://github.com/alanlb195/clean-architecture-template](https://github.com/alanlb195/clean-template-nest)

En este repositorio encontrar√°s la estructura completa, ejemplos reales, casos de uso, repositorios, servicios y todo lo necesario para utilizar esta plantilla como base en tus propios desarrollos con NestJS.
